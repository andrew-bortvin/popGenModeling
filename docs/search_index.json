[["index.html", "Population Genetics Modeling 1 Homepage", " Population Genetics Modeling 1 Homepage This is the course homepage and digital textbook for Population Genetics Modeling (AS.020.369). 1.0.0.1 Instructor Andrew Bortvin, abortvi2[at]jhu.edu 1.0.1 Course Updates 8/21: Introductory R chapters added under R Guidebook 8/21: Syllabus added to website 8/21: Course website is live! "],["course-syllabus.html", "2 Course Syllabus", " 2 Course Syllabus COMPUTATIONAL APPROACHES TO POPULATION GENETICS Instructor: Andrew Bortvin Times: Tuesday, Thursday 3:00PM - 4:30PM Location: UG Teaching Lab (UTL) 189 Office Hours: Wednesday 9:00-10:00 AM and 5:00-6:00 PM, or by appointment; Levi 251 Course website: https://andrew-bortvin.github.io/popGenModeling/ 2.0.1 Course Description The size, composition, and genetics of populations fluctuate over time. These fluctuations are the product of dynamics between individuals, the interactions between populations, and the context of a population within a broader ecological landscape. The quantitative tools developed to study population genetics allow biologists to discover the simple fundamental principles that govern these complex systems. This course will introduce the basic theory of population genetics while teaching students the fundamental skills of programming in the R programming language, which will allow them to directly implement and visualize theoretical concepts. Students will model and simulate theoretical populations and analyze population-scale genomic data. This course will examine evolution on a variety of scales, ranging from the competition between cells within a single organism, to population dynamics in conservation biology that span decades, to the evolution of contemporary human populations over hundreds of thousands of years. 2.0.2 Learning Goals By the end of this course, students will be able to: • outline, using biological theory and terms, how populations grow and interact with each other • describe the external factors that can cause changes in genetic diversity and use this information to predict how specific demographic scenarios would impact a population • manipulate, analyze, and visualize data using the R programming language • describe and interpret common formats used to store genomic data, and implement standard analytic protocols used to analyze these data types 2.0.3 Grading 30% Participation 40% Weekly Assignments 30% Final Project Weekly Assignments Class sessions will consist of a lecture in which theory is introduced, instructor-led live-coding sessions that implement the models studied in class, and time for students to work independently on assignments that further develop the models designed in class. Most weeks, there will be a take-home assignment that extends concepts studied in class. Students will have a week to complete problem sets. After submission, students will receive feedback from the instructor on each assignment and will have until the end of the semester to submit any revisions necessary. Each assignment will consist of a set of required exercises that can be completed by students of any coding background. These will be followed by optional, more computationally-focused exercises, which will allow students to examine more intricate evolutionary scenarios and implement more complicated computational models. Work will be graded on reasonable completion–that is to say, code that demonstrates an understanding of an algorithm and its general implementation will receive full marks, regardless of whether output is exactly correct. Students will also be assessed on the clarity and interpretability of the data visualizations that their code outputs and the accuracy of their responses to short questions prompting biological interpretation of their results. Google and AI Googling is always an acceptable way to find answers or help, and I encourage you to utilize it extensively. If you adopt a solution following a Google search, make sure you understand what you incorporate, rather than just copy/paste without comprehension of the logic or code. Google is also a good way to learn more about any error messages you encounter in your code. You may be familiar with ChatGPT and other large language models. After trying each problem/assignment/task on your own, if you’re still running into issues, feel free to use ChatGPT as you would any other online resource (Google, stack overflow, etc.). Learning how to succinctly describe exactly what you want to accomplish is a skillset in itself, so this can be good practice. If you find code that seems to work (e.g., from Google) but you’re not sure how exactly it works, you can also type it into ChatGPT and ask it to explain what’s happening. As always, please do not submit any code if you are not familiar entirely with how it works; flag it and ask an instructor for assistance. Be aware that ChatGPT might confidently offer an answer that is not correct; so always check the output on your own. 2.0.4 Schedule First Week - Introduction to Population Genetics Modeling Date Topic Assignments August 27 Welcome; Course Overview August 29 Introduction to R Programming - Working with Data, Plotting DUE: Create a Posit account Unit One: Population Biology How do population sizes change? Models for one and two populations. Cooperation, Competition, and predation. Week Two: One Population Models Date Topic Assignments September 3 The Exponential and Logistic Growth Models September 5 Density-Dependent Growth Problem Set 1 Assigned Week Three: Multiple Populations September 10 Lotka-Volterra dynamics 1: Competition and Cooperation September 12 Lotka-Volterra dynamics 2: Predation and Parasitism Problem Set 1 Due; Problem Set 2 Assigned Week Four: Advanced Topics in Population Biology September 17 Spatial Models September 19 Social Evolution and Game Theory Problem Set 2 Due; Problem Set 3 Assigned Unit Two: Population Genetics How do we measure the genetic relationships between individuals? Between Populations? Between Species? What determines the fate of a genetic element in a population? How does the size and demographic history of a population impact its genetic composition? Biological Simulation Week Five: The Wright Fisher Model September 24 The Wright-Fisher Model: Evolutionary Neutrality September 26 The Wright-Fisher Mode 2: Types of Selection, Selective Sweeps Problem Set 3 Due; Problem Set 4 Assigned Week Six: Multiple Loci - Measures of Genetic Variation October 1 Nucleotide Diversity, the Site Frequency Spectrum October 3 F statistics Problem Set 4 Due Week Seven: Biological Simulation and Population Size Changes October 8 The SLiM Programming Language and slimr Problem Set 5 Assigned October 10: Population Bottlenecks, Population Expansion, and Genetic Diversity Week Eight: Biological Simulation and Population Size Changes Continued October 15 Population Size Changes and the Site Frequency Spectrum Problem Set 5 Due October 17 Fall Break Week Nine: Multiple Populations and Genetic Relatedness October 22 Simulation with Multiple Populations - Migration Problem Set 6 Assigned October 24 Simulation with Multiple Populations - Admixture, Local Adaptation Unit Three: Analyzing Genetic Data How are population-scale genetic variants represented? How do we quantify relatedness between populations? Tests for selection, association testing, fine mapping. Phylogeny Week Ten: Association Testing October 29 The Variant Call Format and population-scale data Problem Set 6 Due October 31 GWAS, linkage disequilbrium, Fine Mapping Problem Set 7 Assigned Week Eleven: Population Structure and Phylogeny November 5 Population structure: PCA, STRUCTURE, and clustering methods November 7 The Coalescent - Inferring Timing of Selection Problem Set 7 Due Week Twelve: Constructing and Interpreting Phylogenies November 12 Working with Phylogenetic Trees - the ape and phytools packages Problem Set 8 Assigned November 14 Tree Comparison Methods, Advanced trees DUE: Finalized proposals for independent/small Group projects Week Thirteen: Independent/Small Group Projects November 19 Work on Independent/Small Group Projects Problem Set 8 Due November 21 Work on Independent/Small Group Projects Week Fourteen: December 3 Evolutionary Methods in Other Fields (Linguistics, Economics, etc.) Current Directions in Population Genetics December 5 Project Presentations and Discussion Independent/Small Group Projects Due December 19: All revisions for weekly assignments due "],["lecture-notes.html", "3 Lecture Notes ", " 3 Lecture Notes "],["class-2-intro-to-r.html", "3.1 Class 2: Intro to R", " 3.1 Class 2: Intro to R 8/27/2024 Today I want to give a pretty broad overview of the basics of using R. There are three big topics that I want to hit upon today. The first is just the basics of the language - what are the standard ways we interface with R? What data can we work with? So on. Secondly, I want to introduce you to working with tabular data. Data tables are the heart and soul of R, and so today we’ll learn how to make them, read them in from a file, and manipulate them. And lastly, I want to teach you a bit of the basics of plotting in R. Every line of code that we write in an R script evaluates, unless we preface it with the hashtag #. In that case, everything in the line of code following the # is a comment and is ignored by the interpreter. We can run our script by clicking, or with the nice hotkey Shift+Command+Return (Windows: Shift+Control+Enter). We can run our individual lines with Command+Return (Windows: Control+Enter). 3.1.1 Data Types, Variables, Math 3.1.1.1 Characters and Variables In R, we have access to a lot of different data types. Text data is called Character data and is denoted by single or double quotes: &quot;ant&quot; ## [1] &quot;ant&quot; We’ve just written down that string and not actually done anything with it. Typically, though, we want to save and store our data for future use. We can do this using variables. We assign a variable using the operators &lt;- or =. For our purposes these are interchangeable for assignment; if you look at code online you’ll likely see both. I use &lt;- since it is a little more common. insect &lt;- &quot;cicada&quot; Now we have a thing in memory with the name insect. And associated with that name is some data - in this case, the word “ant”. Incidentally, you can see in the top right corner of your screen in the Environment tab there is now an insect variable with the associated word “ant”. And now, whenever we want to access that data, we can use its variable name. For example, the print() function allows us to, fittingly, print data to the screen. We can print the contents of insect as such: print(insect) ## [1] &quot;cicada&quot; And so just one bit of nomenclature - here, print() is the function, and insect - the thing we give to the function - is the function’s argument. A little more about assignment: we can “overwrite” a variable by assigning new data to it. insect &lt;- &quot;ant&quot; print(insect) ## [1] &quot;ant&quot; Now, insect is associated with the value \"ant\". The old value is removed and the new one is added in its place. I’ve just told you that insect is character data, but if you ever are working with data and you don’t know the type of data it is, you can investigate that using the class() function: class(insect) ## [1] &quot;character&quot; 3.1.1.1.1 paste We have two very helpful functions for combining strings paste and paste0. paste(insect, &quot;hill&quot;) ## [1] &quot;ant hill&quot; We can give paste() a separator to combine with a common delimiter: paste(&quot;eye&quot;, &quot;of&quot;, &quot;newt&quot;, sep = &quot;,&quot;) ## [1] &quot;eye,of,newt&quot; paste0() is a shorthand of writing sep = \"\" print(paste(insect, &quot;hill&quot;, sep = &quot;&quot;)) ## [1] &quot;anthill&quot; print(paste0(insect, &quot;hill&quot;)) ## [1] &quot;anthill&quot; 3.1.1.2 Numbers In many programming languages, you need to be very careful about different types of data - the difference between integers and numbers with decimal points is often extremely critical. R simplifies this a lot - under the hood, there are differences between these data types, but for our purposes we can broadly treat them as one type of data - numeric data. Math is straightforward: aNumber &lt;- 3.14 print(aNumber + 2) ## [1] 5.14 Notice that this does not modify the original value of aNumber: print(aNumber) ## [1] 3.14 To do that, we must use the assignment operator: aNumber &lt;- aNumber * 2 print(aNumber) ## [1] 6.28 Other Math: print(5 + 2.2) # Notice the accommodation of integers and floating point data ## [1] 7.2 print(7/3) # Division ## [1] 2.333333 print(9*4) # Multiplication ## [1] 36 print(2**3) # Exponents ## [1] 8 This last point about math is fairly intuitive, so I don’t need to dwell on it too long, but R obeys standard order of operations. Just like in real math, you can use parenthesis to control the order of operations. print(1 + 3 * 2) ## [1] 7 print((1 + 3) * 2) ## [1] 8 3.1.1.3 Logical Data R can represent whether conditions are true or false using the appropriately named, case-sensitive TRUE and FALSE. These can shortened to T and F. A really nifty part of these is that they can also be automatically converted to the numeric 1 for TRUE and 0 for FALSE. T + TRUE + FALSE ## [1] 2 Now that we’ve seen the three major data types, one last thing about the assignment operator. Assignment can change the type of a variable. For example: testData &lt;- 5 print(class(testData)) ## [1] &quot;numeric&quot; testData &lt;- &quot;yes&quot; print(class(testData)) ## [1] &quot;character&quot; 3.1.2 Comparing Values Logical data most commonly appears when we compare values. We compare equality using the double equals sign: print(&quot;egg&quot; == &quot;egg&quot;) ## [1] TRUE print(&quot;Egg&quot; == &quot;egg&quot;) ## [1] FALSE We can invert this using the != operator: print(2 != 3) ## [1] TRUE We can likewise use &gt; and &lt; to check if things are greater or less than each other. print(5 &gt; 2.2) ## [1] TRUE &gt;= and &lt;= are greater than/less or equal to: print(3 &lt;= 3) ## [1] TRUE We can also use the exclamation point ! to negate logic in R: print(!TRUE) ## [1] FALSE print(!(3 &gt; 2)) ## [1] FALSE 3.1.2.1 Multiple Conditions AND and OR operators are used to evaluate multiple conditions. Any number of conditions connected by AND and OR operators return only one TRUE or FALSE value. 3.1.2.1.1 AND The logical AND is denoted by the operator &amp;. Two conditions connected by &amp; evaluate as TRUE only if both are TRUE: (5 + 2 ==7) &amp; (&#39;a&#39; != &#39;b&#39;) # True and True ## [1] TRUE If a single condition is FALSE, the entire statement is FALSE: (3 + 2 &lt; 4) &amp; (5 &gt; 2) # False and True ## [1] FALSE 3.1.2.1.2 OR The logical OR is denoted by the operator |. Two conditions connected by | evaluate as TRUE if either condition is TRUE: (7 &gt;= 3) | (2 == 3) # True and False ## [1] TRUE 3.1.3 Collections Most of the time, our data doesn’t come in the form of individual discrete observations. Instead, we usually work with collections of data - for example, the size of a population across many years. The most basic kind of collection in R is the vector, which combines multiple data points of the same type. We create a vector using the function c() (stands for concatenate). fruits &lt;- c(&quot;peach&quot;, &quot;plum&quot;, &quot;pear&quot;) print(fruits) ## [1] &quot;peach&quot; &quot;plum&quot; &quot;pear&quot; If we mix data of multiple types, R automatically converts data, to the best of its ability: fruits &lt;- c(&quot;peach&quot;, 5.2, &quot;pear&quot;) print(fruits) ## [1] &quot;peach&quot; &quot;5.2&quot; &quot;pear&quot; Notice that the numeric 5.2 is converted to the character \"5.2\" (see the quotation marks). 3.1.3.1 Adding to vectors We can use the c() function to add to an existing vector: fruits &lt;- c(fruits, &quot;apple&quot;) print(fruits) ## [1] &quot;peach&quot; &quot;5.2&quot; &quot;pear&quot; &quot;apple&quot; 3.1.3.2 Indexing We can extract from a vector using the brackets []. Inside the brackets, put the position of the item you want to extract: print(fruits) ## [1] &quot;peach&quot; &quot;5.2&quot; &quot;pear&quot; &quot;apple&quot; print(fruits[2]) # Get the second item ## [1] &quot;5.2&quot; print(fruits[length(fruits)]) # Get the last item ## [1] &quot;apple&quot; We can provide a range or a vector of positions to extract multiple items from our vector: print(fruits[2:4]) ## [1] &quot;5.2&quot; &quot;pear&quot; &quot;apple&quot; print(fruits[c(1,3,2)]) ## [1] &quot;peach&quot; &quot;pear&quot; &quot;5.2&quot; We can combine indexing and the assignment operator to modify a vector. For example, changing \"5.2\" back to \"plum\": fruits[2] &lt;- &quot;plum&quot; print(fruits) ## [1] &quot;peach&quot; &quot;plum&quot; &quot;pear&quot; &quot;apple&quot; 3.1.3.3 Comparisons with vectors We can use our comparison operators with vectors to compare the entire vector to a value. myNumbers &lt;- c(4, 10, 8, 2) myNumbers &gt; 5 ## [1] FALSE TRUE TRUE FALSE We return a vector of logical values! 3.1.3.4 Two other major types of collections: 3.1.3.4.1 Rep We often want to repeat elements a set number of times. Writing this out by hand is annoying, so there’s a helpful function to do it for you: rep(). rep(5, times = 4) ## [1] 5 5 5 5 This repeats 5 four times. We can also repeat vectors: rep(c(&#39;stop&#39;, &#39;go&#39;), times = 4) ## [1] &quot;stop&quot; &quot;go&quot; &quot;stop&quot; &quot;go&quot; &quot;stop&quot; &quot;go&quot; &quot;stop&quot; &quot;go&quot; What if we want to repeat each element in the vector a set number of times before moving on to the next? e.g. we want to turn c(\"a\", \"b\") into c(\"a\",\"a\",\"a\", \"b\",\"b\",\"b\")? rep(c(&#39;a&#39;, &#39;b&#39;), each = 3) ## [1] &quot;a&quot; &quot;a&quot; &quot;a&quot; &quot;b&quot; &quot;b&quot; &quot;b&quot; So, notice that this the first function we’ve encountered that takes multiple arguments. Multiple arguments are extremely common. For most functions, the first argument will be the input data or a formula or something. It doesn’t need a name - R can figure that out on its own. After that, though, most arguments are optional. So if you give R the code rep(c('stop', 'go'), 4), it won’t automatically know what that 4 means - it could be either times or each in that position. So it’s a good practice to explicitly tell R what your optional arguments are by writing their name. Incidentally, how do we know what these optional arguments can be? This is something we need to know on a function-by function basis, and the ones for the common functions will be second nature to you sooner than you think. But also, we can look up our functions documentation using ?rep. And if our function is not from the default R language, we can do a broader search using ??rep? 3.1.3.4.2 seq We often want to work with a series of numbers in order (1,2,3,4,5,…,n). The seq() function allows us to do this. Let’s look at it in a bit more detail: seq(5) ## [1] 1 2 3 4 5 We can give seq() multiple numbers to create a start and stop condition: seq(1, 10) ## [1] 1 2 3 4 5 6 7 8 9 10 seq(7,3) ## [1] 7 6 5 4 3 Two important optional arguments for seq() seq(5,20, by = 5) ## [1] 5 10 15 20 seq(4,9, length = 12) ## [1] 4.000000 4.454545 4.909091 5.363636 5.818182 6.272727 6.727273 7.181818 ## [9] 7.636364 8.090909 8.545455 9.000000 3.1.4 Iteration An extremely common thing for us is that we will want to perform actions over and over again. Say you have 30 individuals in a population and every generation it gets 10% bigger. We can write that out over and over, but it gets tiring and impractical soon. for (i in seq(1, 5)){ print(i) } ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 So what we do here is take this sequence of 5 items. For each item, we take this temporary variable i, and we perform an action on it. Here, we just print it out. for (i in seq(1, 5)){ i &lt;- 2**i print(i &gt; 6) } ## [1] FALSE ## [1] FALSE ## [1] TRUE ## [1] TRUE ## [1] TRUE We don’t need to operate on i directly. For example, to implement that population example: N &lt;- 30 for (i in seq(1, 8)){ N &lt;- N * 1.1 print(N) } ## [1] 33 ## [1] 36.3 ## [1] 39.93 ## [1] 43.923 ## [1] 48.3153 ## [1] 53.14683 ## [1] 58.46151 ## [1] 64.30766 So, here we take this variable N and we make it 10% bigger 8 times using our loop. The last thing I want to touch upon here is that we put a for loop inside a for loop: for (i in c(&quot;b&quot;, &quot;c&quot;)){ for (j in c(&quot;at&quot;, &quot;ar&quot;)){ print(paste0(i, j)) } } ## [1] &quot;bat&quot; ## [1] &quot;bar&quot; ## [1] &quot;cat&quot; ## [1] &quot;car&quot; 3.1.5 Data Frames: Tabular Data So vectors are great, but usually we don’t keep track of just one thing - we normally have multiple variables that we track simultaneously - for example, time and population size. A data frame is a tabular data structure that lets us organize a lot of different data in one place. Each column in a data frame is a vector - so within each column, the data needs to be of the same type. However, each column can be its own data type. So to make this concrete, let’s build a simple data frame with some made up data: myDf &lt;- data.frame( numbers = c(1, 4, 6, 2, 3.3), logic = c(T, T, F, F, T), words = c(&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;orange&quot;, &quot;turquoise&quot;) ) myDf ## numbers logic words ## 1 1.0 TRUE red ## 2 4.0 TRUE green ## 3 6.0 FALSE blue ## 4 2.0 FALSE orange ## 5 3.3 TRUE turquoise So now that we’ve made a simple dataset, let’s load in some more elaborate real data. penguins &lt;- read.csv(&quot;penguins.csv&quot;) We have a few ways of quickly looking at our data: head(penguins) ## species island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g ## 1 Adelie Torgersen 39.1 18.7 181 3750 ## 2 Adelie Torgersen 39.5 17.4 186 3800 ## 3 Adelie Torgersen 40.3 18.0 195 3250 ## 4 Adelie Torgersen NA NA NA NA ## 5 Adelie Torgersen 36.7 19.3 193 3450 ## 6 Adelie Torgersen 39.3 20.6 190 3650 ## sex ## 1 MALE ## 2 FEMALE ## 3 FEMALE ## 4 ## 5 FEMALE ## 6 MALE tail(penguins) ## species island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g ## 339 Gentoo Biscoe 47.2 13.7 214 4925 ## 340 Gentoo Biscoe NA NA NA NA ## 341 Gentoo Biscoe 46.8 14.3 215 4850 ## 342 Gentoo Biscoe 50.4 15.7 222 5750 ## 343 Gentoo Biscoe 45.2 14.8 212 5200 ## 344 Gentoo Biscoe 49.9 16.1 213 5400 ## sex ## 339 FEMALE ## 340 ## 341 FEMALE ## 342 MALE ## 343 FEMALE ## 344 MALE and View(penguins), which is analogous to clicking on it in the Environment tab. So we can only see the first seven columns of our data here - if we ever want to know what all the columns are, we can use the names() function: names(penguins) ## [1] &quot;species&quot; &quot;island&quot; &quot;bill_length_mm&quot; ## [4] &quot;bill_depth_mm&quot; &quot;flipper_length_mm&quot; &quot;body_mass_g&quot; ## [7] &quot;sex&quot; We can also pretty easily get the dimensions of our data: nrow(penguins) ## [1] 344 ncol(penguins) ## [1] 7 dim(penguins) ## [1] 344 7 3.1.5.1 Subsetting We can extract columns from our data frame using the dollar sign. So for example if I want to see the island column, I can do: penguins$island Which we can now index the usual way: penguins$island[5:10] ## [1] &quot;Torgersen&quot; &quot;Torgersen&quot; &quot;Torgersen&quot; &quot;Torgersen&quot; &quot;Torgersen&quot; &quot;Torgersen&quot; We can also index the entire df the conventional way, but now we need to provide a row and column index: penguins[5, 10] ## NULL 3.1.5.2 Logical Indexing Let’s say that we want the penguins with big bills. We can use logical comparisons with the bill_length_mm vector to find which ones are 40 mm or longer. penguins$bill_length_mm &gt;= 40 This creates a huge vector of TRUEs and FALSEs. We can give this as a row index to pull out the TRUE rows: penguins[penguins$bill_length_mm &gt;= 40, ] Notice that the column index is blank - this means that we want to pull out all columns. Notice that we retain rows where the bill length is NA are retained. The easiest way to address this is to remove rows with NAs. Checking for NA values in R is a bit finicky. The conventional way is to use the function is.na(). This returns TRUE for all NAs. We want the opposite of that, so we add in ! to negate it: penguins[penguins$bill_length_mm &gt;= 40 &amp; !is.na(penguins$bill_length_mm), ] We can also use this type of logical comparisons to answer the question of how many penguins have long bills. penguins$bill_length_mm &gt;= 40 returns a logical vector of T and F. Recall that these are equivalent to 1 and 0. So to find the number of TRUEs, we can just sum the vector: sum(penguins$bill_length_mm &gt;= 40, na.rm = TRUE) ## [1] 242 Again, we need to remove the NAs for this to work as intended, so the sum function has an optional na.rm argument. 3.1.6 Plotting For plotting, we use the external library ggplot2. This library is installed but because it is not a part of the base R programming language, we need to let R know that we will be using it. This is done with the following line of code: library(ggplot2) To create a plot, we need to provide a data set that we will plot, along with defining some aesthetics (axes, colors, groups of data, etc.). Almost always, we will need to define the x and y axes. Let’s start by plotting the bill length and body mass of our penguins. ggplot(penguins, aes(x = body_mass_g, y = bill_length_mm)) This already creates a nice plot. Notice that the axes are already scaled around your data. Now we can add points. To add a geometric, we use the addition operator + to add a type of geometric object to our plots: ggplot(penguins, aes(x = body_mass_g, y = bill_length_mm)) + geom_point() ## Warning: Removed 2 rows containing missing values or values outside the scale range ## (`geom_point()`). Now, we can also color our data by a different variable. This involves adding a color term to aes For example, recoloring by sex: ggplot(penguins, aes(x = body_mass_g, y = bill_length_mm, color = sex)) + geom_point() ## Warning: Removed 2 rows containing missing values or values outside the scale range ## (`geom_point()`). You may notice that some of our penguins are missing sex information. This is coded by an empty string \"\" rather than an NA. We can filter these out as such: penguinsFiltered &lt;- penguins[penguins$sex != &quot;&quot;, ] We retain just the rows where the sex column is not equal to \". Plotting this new dataset: ggplot(penguinsFiltered, aes(x = body_mass_g, y = bill_length_mm, color = sex)) + geom_point() Another way to separate variables is to create multiple subplots. This is mostly easy done by adding facet_wrap() to our ggplot() statement. To facet_wrap(), we give the name of the column that we want to split by. For example, splitting the above plot by island: ` ggplot(penguinsFiltered, aes(x = body_mass_g, y = bill_length_mm, color = sex)) + geom_point() + facet_wrap(&quot;island&quot;) Notice that for facet_wrap(), we need to give the column name in quotation marks. 3.1.7 Wide to Long One thing you may have noticed is that when we plot our data, we want our data to be tall rather than wide. To make that a little more concrete, here’s a data set of population sizes for two species: popSizes &lt;- data.frame( generation = seq(1,5), species1 = c(10, 12, 15, 13, 14), species2 = c(20, 15, 14, 13, 11) ) head(popSizes) ## generation species1 species2 ## 1 1 10 20 ## 2 2 12 15 ## 3 3 15 14 ## 4 4 13 13 ## 5 5 14 11 So if we go to plot this, we hit an issue: ggplot(popSizes, aes(x = generation, y = #????)) There are a few workarounds for this, but one of the best ones is to reshape your data and make it taller. The reshape2 library has a great function for this is: library(reshape2) popSizesTall &lt;- melt(popSizes, id.vars = &quot;generation&quot;) head(popSizesTall) We should now rename our columns to be a bit more descriptive. This can be done with the colnames() function: colnames(popSizesTall) &lt;- c(&quot;generation&quot;, &quot;species&quot;, &quot;size&quot;) Plotting is now straightforward: ggplot(popSizesTall, aes(x = generation, y = size, color = species)) + geom_point() + geom_line() + theme_classic() library(ggplot2) library(reshape2) "],["class-3-exponential-growth-and-age-structure.html", "3.2 Class 3: Exponential Growth and Age Structure", " 3.2 Class 3: Exponential Growth and Age Structure Today, we’re looking at the exponential growth model, which describes how a population grows in the absence of density dependence - that is, when the growth rate doesn’t change in response to population size. First, we’ll plot exponential growth for one population at a given per capita growth rate. # Initialize parameters N &lt;- 50 # Population Size r &lt;- 0.04 # Per capita growth rate lambda &lt;- 1 + r n_generations &lt;- 50 # Vector to keep track of population size popSize &lt;- c(N) # Run simulation for (i in seq(n_generations)){ N &lt;- N * lambda # Calculate next generation popSize &lt;- c(popSize, N) } # Organize into data frame df &lt;- data.frame( generation = seq(0, n_generations), popSize = popSize ) # Plot ggplot(df, aes(x = generation, y = popSize)) + geom_point() + xlab(&quot;Generation&quot;) + ylab(&quot;Population Size&quot;) + ggtitle(&quot;Exponential Growth&quot;) + theme_bw() Next, plotting across multiple growth rates: # Initialize parameters n_generations &lt;- 50 # Vectors to track variable generations &lt;- c() popSizeList &lt;- c() growthRate &lt;- c() # Tracking growth rate so that we can separate our data by rate when plotting # Run simulation for (growth_rate in c(-0.1, 0, 0.02, 0.04)){ # Loop through all the growth rates (i.e. run simulation once for each rate) lambda &lt;- 1 + growth_rate # Get lambda for the current growth rate N &lt;- 50 # Reset starting population size to 50 popSize &lt;- c(N) # Track population size for current run of the simulation # Run simulation for 50 generations for (i in seq(n_generations)){ N &lt;- N * lambda popSize &lt;- c(popSize, N) } # Update vectors with simulation output generations &lt;- c(generations, seq(0, n_generations)) popSizeList &lt;- c(popSizeList, popSize) growthRate &lt;- c(growthRate, rep(lambda, n_generations + 1)) } # Reorganize into a data frame df &lt;- data.frame( generations = generations, popSize = popSizeList, growthRate = growthRate ) # Plot ggplot(df, aes(x = generations, y = popSize, color = factor(growthRate))) + geom_point() + xlab(&quot;Generation&quot;) + ylab(&quot;Population Size&quot;) + ggtitle(&quot;Exponential Growth&quot;) + theme_bw() + labs(color = &quot;Growth Rate&quot;) # Change label of the color legend Notice that our population decreases when lambda &lt; 1, stays constant when lambda = 1, and increases when lambda &gt; 1. 3.2.1 Comparison to Real Data I’ve pulled some data from Yoav et al. 2019, PNAS (https://doi.org/10.1073/pnas.1902217116). This data set tracks microbial growth across a series of plates. Reading in the data: yoavData &lt;- read.csv(&quot;yoavData.csv&quot;, row.names = &quot;X&quot;) head(yoavData) The data has three columns: Time.S - the time in seconds, Plate - the name of the plate that the culture is grown in, and Size - the size of the colony. First, plotting the size of the colony for the first 13,000 seconds: ggplot(yoavData, aes(x = Time.S, y = Size, color = Plate)) + geom_point() + geom_line() + theme(legend.position = &quot;none&quot;) + xlab(&quot;Time (Seconds)&quot;) + ylab(&quot;Population Size&quot;) + xlim(c(0, 13000)) + ylim(c(0, 300000)) Visually, this looks exponential. We can fit a curve to it. To do this, we can use the function lm() which fits a linear model. The tilde (~) symbol indicates the relationship we want to measure - in other words, this equation measures log(Size) as a function of Time. To make this an exponential fit, we take the log of the dependent variable: fitData &lt;- yoavData[yoavData$Time.S &lt; 15000, ] lm(log(fitData$Size) ~ fitData$Time.S) We can plot this along the real-world data. # Creating a dataframe from our function xs &lt;- seq(1, 60000) # Set the x values we want to evaluate ys &lt;- exp(10.067264) * exp(0.000182 * xs) # Get the corresponding values using coefficients from the fit fit_line &lt;-data.frame(Time.S = xs, # Convert to data frame Size = ys, Plate = &quot;fit&quot;) # Notice that the names we give above # Match the names of the axes of our plotting data. # We also give create a column &quot;Plate&quot; for color-coding # Plot data ggplot(yoavData, aes(x = Time.S, y = Size, color = Plate)) + geom_point() + geom_line() + xlab(&quot;Time (Seconds)&quot;) + ylab(&quot;Population Size&quot;) + geom_line(data = fit_line, size = 1, color = &quot;black&quot;) + # Plot the line of best fit theme(legend.position = &quot;none&quot;) + xlim(c(0, 13000)) + ylim(c(0, 300000)) Notice that when we add the line of best fit, we provide the argument data = fit_line. This tells ggplot that we are using a second data set not provided in the initial ggplot call. Now, let’s plot our data extending further in time - this is done by changing the xlim arguments: xs &lt;- seq(1, 60000) ys &lt;- exp(10.067264) * exp(0.000182 * xs) fit_line &lt;-data.frame(Time.S = xs, Size = ys, Plate = &quot;fit&quot;) ggplot(yoavData, aes(x = Time.S, y = Size, color = Plate)) + geom_point() + geom_line() + xlab(&quot;Time (Seconds)&quot;) + ylab(&quot;Population Size&quot;) + geom_line(data = fit_line, size = 1, color = &quot;black&quot;) + theme(legend.position = &quot;none&quot;) + xlim(c(0, 35000)) + # Changed x limits to see further into the Time ylim(c(0, 800000)) Notice that as the population grows, the exponential model is an increasingly poor fit - the exponential model predicts continued growth at an increasing rate; the actual data shows growth slowing down until the population hits a plateau. We’ll look at this discrepancy in more detail next class! 3.2.2 Age Structure Next, let’s look at age structured populations - that is a population where we track the ages of individuals and where individuals of different ages can have different reproduction rates and mortalities. We’ll start with a simplified population of 0 and 1-year olds. In each generation, the number of 1 year olds in the next generation is determined purely by the number of 0 years olds that survive the year, and the number of 0 year olds is determined by the sum of the number 0 year olds and the number of 1 year olds that reproduce. # Initializing parameters # Initial numbers of 0 and 1 year olds N0 &lt;- 2 N1 &lt;- 10 # Birth Rates for 0 and 1 year olds f0 &lt;- 0.4 f1 &lt;- 1.8 # Death Rates # Just for 0 year olds - all 1 year olds die S0 &lt;- 0.7 n_generations &lt;- 50 # Empty vectors to store data n0_list &lt;- c() n1_list &lt;- c() # Run simulation for (i in seq(n_generations)){ # Calculate the number of 0 and 1 year olds in the next generation N0_next_gneration &lt;- N0 * f0 + N1 *f1 N1_next_generation &lt;- N0 * S0 # Update values N0 &lt;- N0_next_gneration N1 &lt;- N1_next_generation # Add to lists n0_list &lt;- c(n0_list, N0) n1_list &lt;- c(n1_list, N1) } # Organize into data frame df &lt;- data.frame( n0 = n0_list, n1 = n1_list, generation = seq(n_generations) ) # Convert to tall format df &lt;- melt(df, id.vars = &quot;generation&quot;) colnames(df) &lt;- c(&quot;Generation&quot;, &quot;Age&quot;, &quot;PopulationSize&quot;) # Plot ggplot(df, aes(x = Generation, y = PopulationSize, color = Age)) + geom_point() + geom_line() + theme_classic() + ylab(&quot;Population Size&quot;) This looks like normal exponential growth, with slightly different rates for 0 and 1 year olds. However, let’s zoom in on early time points: ggplot(df, aes(x = Generation, y = PopulationSize, color = Age)) + geom_point() + geom_line() + theme_classic() + ylab(&quot;Population Size&quot;) + xlim(c(0, 10)) + ylim(c(0,400)) The last thing we want to do with this data is plot the ratio of 0 to 1 year olds: # Initializing parameters # Initial numbers of 0 and 1 year olds N0 &lt;- 2 N1 &lt;- 10 # Birth Rates for 0 and 1 year olds f0 &lt;- 0.4 f1 &lt;- 1.8 # Death Rates # Just for 0 year olds - all 1 year olds die S0 &lt;- 0.7 n_generations &lt;- 50 # Empty vectors to store data ratio_list &lt;- c(N0/N1) # Run simulation for (i in seq(n_generations)){ # Calculate the number of 0 and 1 year olds in the next generation N0_next_gneration &lt;- N0 * f0 + N1 *f1 N1_next_generation &lt;- N0 * S0 # Update values N0 &lt;- N0_next_gneration N1 &lt;- N1_next_generation # Add to list ratio_list &lt;- c(ratio_list, N0/N1) # Calculate the ratio of 0/1 year olds } # Organize into a data frame ratioDf &lt;- data.frame( generations = seq(0, n_generations), ratio = ratio_list ) # Plot ggplot(ratioDf, aes(x = generations, y = ratio)) + geom_point() + geom_line() + theme_bw() + xlab(&quot;Generation&quot;) + ylab(&quot;Ratio 0:1 Year Olds&quot;) Notice that after an initial period of chaos, the ratio of age groups stabilizes. This is called the stable age distribution and is a general property of age structured models like this. 3.2.3 The Leslie Matrix The Leslie matrix allows us to very efficiently extend age structured models to an arbitrarily large number of populations. In the Leslie matrix L, the first row is the fecundity of each category, and the area beneath that has a diagonal arrangement of survival rates for each age category. Note that for matrix multiplication, we use %*%. # Leslie matrix L &lt;- matrix(data = c(0, 0, 0.1, 1.1, 1.8, 0.9, 0.4, 0.1, 0.4, 0, 0, 0, 0, 0, 0, 0, 0, 0.9, 0, 0, 0, 0, 0, 0, 0, 0, 0.8, 0, 0, 0, 0, 0, 0, 0, 0, 0.9, 0, 0, 0, 0, 0, 0, 0, 0, 0.8, 0, 0, 0, 0, 0, 0, 0, 0, 0.2, 0, 0, 0, 0, 0, 0, 0, 0, 0.1, 0), nrow = 8, ncol = 8, byrow = TRUE) # Starting population size for each age class pop_matrix &lt;- as.matrix(c(1, 3, 2, 0, 6, 10, 25, 15)) # Starting population size for each age class total_size &lt;- c(sum(pop_matrix)) n_generations &lt;- 40 # Run simulation for (i in seq(n_generations)){ pop_matrix &lt;- L %*% pop_matrix total_size &lt;- c(total_size, sum(pop_matrix)) } # Organize data into a data frame df &lt;- data.frame( year = seq(0, n_generations), size = total_size ) # Plot ggplot(df, aes(x=year, y = size)) + geom_point() + geom_line() + theme_bw() + xlab(&quot;Time (Year)&quot;) + ylab(&quot;Population Size&quot;) library(ggplot2) library(reshape2) "],["class-5-lotka-volterra-i-competition.html", "3.3 Class 5: Lotka-Volterra I: Competition", " 3.3 Class 5: Lotka-Volterra I: Competition To begin with, a simple implementation of the Lotka-Volterra equation in R, with discrete time points: # Initialize conditions # Population Sizes N1 &lt;- 30 N2 &lt;- 20 # Carrying Capacities K1 &lt;- 1000 K2 &lt;- 400 # Interaction parameters between pops alpha &lt;- 0.1 beta &lt;- 0.9 # Growth rates r1 &lt;- 1.5 r2 &lt;- 1.3 # Simulation time nYears &lt;- 20 # Vectors to store population sizes n1_list &lt;- c(N1) n2_list &lt;- c(N2) # Run simulation for (i in seq(nYears)){ # Calculate future pop sizes for next time point # Saving N1 as a new variable so that it the current value of N1 # can be used to calculate N2 N1_future &lt;- N1 + r1 * N1 * ((K1 - N1 - alpha * N2)/K1) N2_future &lt;- N2 + r2 * N2 * ((K2 - N2 - beta * N1)/K2) # Update N1 and N2 N1 &lt;- N1_future N2 &lt;- N2_future # Save to list n1_list &lt;- c(n1_list, N1) n2_list &lt;- c(n2_list, N2) } # Convert to data frame df &lt;- data.frame( time = seq(length(n1_list)), n1 = n1_list, n2 = n2_list ) # Convert to tall format df &lt;- melt(df, id.vars = &quot;time&quot;) colnames(df) &lt;- c(&quot;time&quot;, &quot;pop&quot;, &quot;size&quot;) # Plot ggplot(df, aes(x = time, y = size, color = pop)) + geom_line() + geom_point() + labs(x = &quot;Time (Generations)&quot;, y = &quot;Population Size&quot;, color = &quot;Population&quot;) + theme_bw() A couple things are apparent from this mode: Under these conditions, both populations are not able to coexist - after a brief period of growth, population 2 collapses to 0. In this model, population 2 dips below 0 at generation 6. The first behavior is fine - it’s a pretty basic property of this model that many parameter combinations lead to one population outcompeting the other to extinction. This is called competitive exclusion. The second behavior - dipping below zero - is not desirable. While our models are theoretical representations of reality, unrealistic behaviors like this are good to correct. Here, shooting below zero happens because with a large step size and a large growth rate, our model moves too quickly. In response to this, we can decrease our step size. In fact, if we decrease our step size enough, our model very closely approximates the continuous form of the equation. # Initialize conditions # Population Sizes N1 &lt;- 30 N2 &lt;- 20 # Carrying Capacities K1 &lt;- 1000 K2 &lt;- 400 # Interaction parameters between pops alpha &lt;- 0.1 beta &lt;- 0.9 # Growth rates r1 &lt;- 1.5 r2 &lt;- 1.3 # Simulation time nYears &lt;- 20 # Vectors to store population sizes n1_list &lt;- c(N1) n2_list &lt;- c(N2) # Create a step size stepSize &lt;- 0.01 # Run simulation for (i in seq(nYears/stepSize)){ # Scale our for loop range by the step size # Calculate future pop sizes for next time point # Saving N1 as a new variable so that it the current value of N1 # can be used to calculate N2 N1_future &lt;- N1 + r1 * N1 * ((K1 - N1 - alpha * N2)/K1) * stepSize # Multiply by step size N2_future &lt;- N2 + r2 * N2 * ((K2 - N2 - beta * N1)/K2) * stepSize # Multiply by step size # Update N1 and N2 N1 &lt;- N1_future N2 &lt;- N2_future # Save to list n1_list &lt;- c(n1_list, N1) n2_list &lt;- c(n2_list, N2) } # Convert to data frame df &lt;- data.frame( time = seq(length(n1_list)), n1 = n1_list, n2 = n2_list ) # Convert to tall format df &lt;- melt(df, id.vars = &quot;time&quot;) colnames(df) &lt;- c(&quot;time&quot;, &quot;pop&quot;, &quot;size&quot;) # Plot ggplot(df, aes(x = time * stepSize, # We multiply time by stepSize to convert back to years y = size, color = pop)) + geom_line() + labs(x = &quot;Time (Generations)&quot;, y = &quot;Population Size&quot;, color = &quot;Population&quot;) + theme_bw() A few changes are needed to make this work: The for loop is changed to incorporate step size: for (i in seq(nYears/stepSize)). If, previously, each step represented one generation, each step now represents one generation * stepSize - just a fraction of the time. In other words, we need to run our model more times to represent an equal amount of real time. When calculating population sizes, we incorporate step size: N1_future &lt;- N1 + r1 * N1 * ((K1 - N1 - alpha * N2)/K1) * stepSize Lastly, when plotting, we convert time back to years by multiplying by stepSize again: ggplot(df, aes(x = time * stepSize, So far, we have seen models where one population outcompetes the other. It is worth noting that this is not an inherent property of Lotka-Volterra models: # Initialize conditions # Population Sizes N1 &lt;- 30 N2 &lt;- 20 # Carrying Capacities K1 &lt;- 1000 K2 &lt;- 1000 # Interaction parameters between pops alpha &lt;- 0.4 beta &lt;- 0.9 # Growth rates r1 &lt;- 1.5 r2 &lt;- 1.3 # Simulation time nYears &lt;- 20 # Vectors to store population sizes n1_list &lt;- c(N1) n2_list &lt;- c(N2) # Create a step size stepSize &lt;- 0.01 # Run simulation for (i in seq(nYears/stepSize)){ # Scale our for loop range by the step size # Calculate future pop sizes for next time point # Saving N1 as a new variable so that it the current value of N1 # can be used to calculate N2 N1_future &lt;- N1 + r1 * N1 * ((K1 - N1 - alpha * N2)/K1) * stepSize # Multiply by step size N2_future &lt;- N2 + r2 * N2 * ((K2 - N2 - beta * N1)/K2) * stepSize # Multiply by step size # Update N1 and N2 N1 &lt;- N1_future N2 &lt;- N2_future # Save to list n1_list &lt;- c(n1_list, N1) n2_list &lt;- c(n2_list, N2) } # Convert to data frame df &lt;- data.frame( time = seq(length(n1_list)), n1 = n1_list, n2 = n2_list ) # Convert to tall format df &lt;- melt(df, id.vars = &quot;time&quot;) colnames(df) &lt;- c(&quot;time&quot;, &quot;pop&quot;, &quot;size&quot;) # Plot ggplot(df, aes(x = time / stepSize, # We multiply time by stepSize to convert back to years y = size, color = pop)) + geom_line() + labs(x = &quot;Time (Generations)&quot;, y = &quot;Population Size&quot;, color = &quot;Population&quot;) + theme_bw() Note that when both populations coexist, they do not hit their carrying capacities: # Initialize conditions # Population Sizes N1 &lt;- 30 N2 &lt;- 20 # Carrying Capacities K1 &lt;- 1000 K2 &lt;- 900 # Interaction parameters between pops alpha &lt;- 0.4 beta &lt;- 0.9 # Growth rates r1 &lt;- 1.5 r2 &lt;- 1.3 # Simulation time nYears &lt;- 20 # Vectors to store population sizes n1_list &lt;- c(N1) n2_list &lt;- c(N2) # Initialize variables to store population size for the logistic model # We start at the same point as the LV model N1_logistic &lt;- N1 N2_logistic &lt;- N2 # Lists to store n1_list_logistic &lt;- c(N1_logistic) n2_list_logistic &lt;- c(N2_logistic) # StepSize stepSize &lt;- 0.01 for (i in seq(nYears/stepSize)){ # Calculate LV dynamics N1_future &lt;- N1 + r1 * N1 * ((K1 - N1 - alpha * N2)/K1) * stepSize N2_future &lt;- N2 + r2 * N2 * ((K2 - N2 - beta * N1)/K2) * stepSize # Update N1 and N2 N1 &lt;- N1_future N2 &lt;- N2_future # Save to list n1_list &lt;- c(n1_list, N1) n2_list &lt;- c(n2_list, N2) # Calculate logistic dynamics N1_logistic &lt;- N1_logistic + r1 * (1 - N1_logistic/K1) * N1 * stepSize N2_logistic &lt;- N2_logistic + r2 * (1 - N2_logistic/K2) * N2 * stepSize # Save to list n1_list_logistic &lt;- c(n1_list_logistic, N1_logistic) n2_list_logistic &lt;- c(n2_list_logistic, N2_logistic) } # Store LV data as a data frame df &lt;- data.frame( time = seq(length(n1_list)), n1 = n1_list, n2 = n2_list ) # Reorganize to a tall dataframe df &lt;- melt(df, id.vars = &quot;time&quot;) colnames(df) &lt;- c(&quot;time&quot;, &quot;pop&quot;, &quot;size&quot;) # Add a column with the model name df[&quot;Model&quot;] = &quot;Lotka-Volterra&quot; # Store Logistic data as a data frame df_logistic &lt;- data.frame( time = seq(length(n1_list_logistic)), n1 = n1_list_logistic, n2 = n2_list_logistic ) # Reorganize to a tall dataframe df_logistic &lt;- melt(df_logistic, id.vars = &quot;time&quot;) colnames(df_logistic) &lt;- c(&quot;time&quot;, &quot;pop&quot;, &quot;size&quot;) # Add a column with the model name df_logistic[&quot;Model&quot;] = &quot;Logistic&quot; # Combine LV and logistic dataframes into one for plotting df_plot &lt;- rbind(df, df_logistic) # Reorganize the factor levels of our plotting data # This determines which population is plotted in dotted lines df_plot$Model &lt;- factor(df_plot$Model, levels = c(&quot;Lotka-Volterra&quot;, &quot;Logistic&quot;)) ggplot(df_plot, aes(x = time / stepSize, y = size, color = pop, linetype = Model)) + geom_line() + labs(x = &quot;Time (Generations)&quot;, y = &quot;Population Size&quot;, color = &quot;Population&quot;) + theme_bw() 3.3.1 Equilibirum from multiple starting points Now, starting from multiple conditions: # Initialize conditions # Carrying Capacities K1 &lt;- 1000 K2 &lt;- 700 # Interaction parameters between pops alpha &lt;- 0.3 beta &lt;- 0.6 # Growth Rates r1 &lt;- 1.5 r2 &lt;- 1.3 # Length of population nYears &lt;- 20 # Lists to store population sizes, trial numbers, and time within each trial n1_all_trials &lt;- c() n2_all_trials &lt;- c() trialNumber &lt;- c() time &lt;- c() # Step Size step &lt;- 0.01 # Number of trials we are running nTrials &lt;- 300 # Run simulation for (trial in seq(nTrials)){ # Randomly generate starting population sizes N1 &lt;- sample(seq(K1), 1) N2 &lt;- sample(seq(K2), 1) # Create a list for population sizes n1_list &lt;- c(N1) n2_list &lt;- c(N2) # Run the simulation for (i in seq(nYears/step)){ # Calculate population size N1_future &lt;- N1 + r1 * N1 * ((K1 - N1 - alpha * N2)/K1) * step N2_future &lt;- N2 + r2 * N2 * ((K2 - N2 - beta * N1)/K2) * step N1 &lt;- N1_future N2 &lt;- N2_future # Add to lists n1_list &lt;- c(n1_list, N1) n2_list &lt;- c(n2_list, N2) } # Add simulation results to overall results n1_all_trials &lt;- c(n1_all_trials, n1_list) n2_all_trials &lt;- c(n2_all_trials, n2_list) trialNumber &lt;- c(trialNumber, rep(trial, time = length(n1_list))) time &lt;- c(time, seq(length(n1_list))) } # Store as data frame df &lt;- data.frame( n1 = n1_all_trials, n2 = n2_all_trials, trial = trialNumber, time = time ) # Plot ggplot(df, aes(x = n1, y = n2, color = factor(trial), # Factor lets R know that trial is a category, not a continuous number alpha = time)) + # Transparency is controlled by time within trial - dark points are the last times within a trial geom_path() + guides(color=&quot;none&quot;, alpha = &quot;none&quot;) + # Remove color and transparency scales xlab(&quot;N1&quot;) + ylab(&quot;N2&quot;) + theme_bw() library(ggplot2) library(reshape2) "],["class-7-infectious-diseases.html", "3.4 Class 7: Infectious Diseases", " 3.4 Class 7: Infectious Diseases Before getting into any biology, let’s learn about making our own functions. Throughout the course, we’ve made use of R functions such as print(), c(), and ggplot(); defining our own functions allows us to Defining our own functions allows us to perform actions over and over on multiple sets of inputs. Below, let’s practice creating a function that takes one input, a list, and returns the number of things in it: # A vector containing the contents of my fridge refrigerator &lt;- c(&quot;Apples&quot;, &quot;Pears&quot;, &quot;Bread&quot;, &quot;Eggs&quot;, &quot;Cheddar&quot;, &quot;Brie&quot;, &quot;Lettuce&quot;, &quot;Shallots&quot;, &quot;Cabbage&quot;) # The function definition countFood &lt;- function(fridge){ # Fridge is a local variable - it does not exist outside the function numItems &lt;- length(fridge) print(paste(&quot;I have&quot;, numItems, &quot;things in my fridge.&quot;)) } # Two more fridges myFriendsPantry &lt;- c(&quot;olives&quot;) fridge &lt;- c(&quot;veal&quot;, &quot;steak&quot;, &quot;halloumi&quot;) # Run the fridge function on all three sets of inputs: countFood(refrigerator) ## [1] &quot;I have 9 things in my fridge.&quot; countFood(myFriendsPantry) ## [1] &quot;I have 1 things in my fridge.&quot; countFood(fridge) ## [1] &quot;I have 3 things in my fridge.&quot; The countFood() function prints out a value, but doesn’t actually store anything to memory. Very often, we want to use the output from our function for downstream analysis. To save the oputput of our function, we need to include a return() statement. For example, the function below generates a poly A tail sequence by pasting together a series of \"A\"’s, taking as input the length of the sequence to return: # Define function polyAtail &lt;- function(length){ polyA &lt;- rep(&quot;A&quot;, times = length) # Create a vector of A&#39;s return(paste(polyA, collapse = &quot;&quot;)) # Convert that vector into a string } # Run polyAtail() function on two inputs polyA &lt;- polyAtail(63) polyA2 &lt;- polyAtail(17) # Print results print(polyA) ## [1] &quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot; print(polyA2) ## [1] &quot;AAAAAAAAAAAAAAAAA&quot; 3.4.1 The SIR Model In the function below, we implement the simplest form of the SIR model. The SIR model tracks the numbers of Susceptible, Infected, and Recovered individuals in a population, assuming a constant birth/death rate. : SIR &lt;- function(S, I, R, # Starting number of individuals, as a fraction of total population size mu, B, gamma, # death/birth rate, contact lengths, recovery rate simTime, step){ # Initialize total population size N &lt;- 1 # lists to store population sizes sList &lt;- c(S) iList &lt;- c(I) rList &lt;- c(R) # loop through times for (time in seq(simTime/step)){ # Calculate rates of change dS &lt;- (mu * (N - S) - B * I * S / N) * step dI &lt;- (B * I * S / N - (mu + gamma) * I) * step dR &lt;- (gamma * I - mu * R) * step # Update population sizes based on rate of change S &lt;- S + dS I &lt;- I + dI R &lt;- R + dR # Update lists sList &lt;- c(sList, S) iList &lt;- c(iList, I) rList &lt;- c(rList, R) } # Store results to data frame df &lt;- data.frame( time = seq(length(sList)) * step, S = sList, I = iList, R = rList ) return(df) } The function above returns a data frame containing time and population size for individuals of all categories. We would also like to plot our data. Since we may want to do this over and over again for different inputs, it also makes sense to plot through a function. Notice that because we just want to create a plot here, we don’t need to save anything to memory. Therefore, this function does not have a return() statement: # Define plotting function plotSIR &lt;- function(SIR_data){ # Convert to tall format SIR_data_tall &lt;- melt(SIR_data, id.vars = &quot;time&quot;) # Fix the column names colnames(SIR_data_tall) &lt;- c(&quot;Time&quot;, &quot;Population&quot;, &quot;Size&quot;) # Plot, coloring by population ggplot(SIR_data_tall, aes(x = Time, y = Size, color = Population)) + geom_line() + theme_bw() } We can also make a function to just plot the infected individuals. This is identical to the function above, except that we subset our individuals while plotting (SIR_data_tall[SIR_data_tall$Population == \"I\", ]): # Define plotting function plotInfected&lt;- function(SIR_data){ # Convert to tall format SIR_data_tall &lt;- melt(SIR_data, id.vars = &quot;time&quot;) # Fix the column names colnames(SIR_data_tall) &lt;- c(&quot;Time&quot;, &quot;Population&quot;, &quot;Size&quot;) # Plot, coloring by population ggplot(SIR_data_tall[SIR_data_tall$Population == &quot;I&quot;, ], aes(x = Time, y = Size, color = Population)) + geom_line() + theme_bw() } Now that we’ve defined our functions, we can run them on a set of data: # Initial fraction of populations in each category S &lt;- 0.19 I &lt;- 0.01 R &lt;- 0.8 mu &lt;- 1/(50 * 52) # Birth rate B &lt;- 2 # Contact lengths gamma &lt;- 0.5 # Recovery rate simTime &lt;- 52 * 100 step &lt;- 0.1 SIR_data &lt;- SIR(S, I, R, mu, B, gamma,simTime, step) plotSIR(SIR_data) plotInfected(SIR_data) As with other multi-population models, we can the trajectories of multiple populations as they relate to each other: ggplot(data=SIR_data, aes(x = S, y = I)) + geom_path() +theme_classic() Note that in this model, there is a cyclical oscillation approaching an equilibrium as time goes on. The new spikes in case number are a result of new births in the population increasing the susceptible population. 3.4.2 SEIR The SEIR model extends the standard SIR model by including a new phase - Exposed individuals. Exposed individuals have contracted the infection but are not yet symptomatic. We’ve also added a couple new terms to make this model more realistic: The parameter p now specifies the at birth vaccination rate. As a result, some fractions of individuals in each generation immediately enter the R category rather than S at birth. The parameter alpha specifies the rate of death induced by the disease. This quantity of individuals is removed from the I population. Because alpha can in fact lead to population size change, we now need to recalculate N with each time step, reflecting the changing total population size. SEIR &lt;- function(S, E, I, R, # Starting number of individuals mu, B, gamma, sigma, alpha, p, # death/birth rate, contact lengths, recovery rate, disease progression rate, death rate from disease, vaccination proportion simTime, step){ # Initialize the total population size (start at 100%) N &lt;- 1 # lists to store population sizes sList &lt;- c(S) eList &lt;- c(E) iList &lt;- c(I) rList &lt;- c(R) # loop through times for (time in seq(simTime/step)){ # Calculate rates of change dS &lt;- (mu * (N * (1-p) - S) - B * I * S / N) * step # (1-p) reflects vaccination dE &lt;- (B * I * S / N - (mu + sigma) * E) * step dI &lt;- (sigma * E - (mu + gamma + alpha) * I) * step dR &lt;- (gamma * I - mu * R + mu * N * p) * step # mu * N * p reflects vaccination # Update population sizes based on rates of change S &lt;- S + dS E &lt;- E + dE I &lt;- I + dI R &lt;- R + dR # Update lists sList &lt;- c(sList, S) eList &lt;- c(eList, E) iList &lt;- c(iList, I) rList &lt;- c(rList, R) # Recalculate total population size N &lt;- sum(S, E, I, R) } # Store results to data frame df &lt;- data.frame( time = seq(length(sList)) * step, S = sList, E = eList, I = iList, R = rList ) return(df) } Now, running on a population: # Initializing proportion of individuals in each population S &lt;- 0.19 E &lt;- 0.0 I &lt;- 0.01 R &lt;- 0.8 mu &lt;- 1/(50 * 52) # Birth rate B &lt;- 2 # Contact lengths sigma &lt;- 0.2 # Time spent exposed prior to symptoms gamma &lt;- 0.5 # Recovery rate alpha &lt;- 0.1 # Death rate from sickness p &lt;- 0.2 # At Birth Vaccination Rate simTime &lt;- 52 * 50 step &lt;- 0.1 # Run Simulation SEIR_data &lt;- SEIR(S, E, I, R, mu, B, gamma, sigma, alpha, p, simTime, step) # Plot plotSIR(SEIR_data) Now, plotting just the infected population: plotInfected(SEIR_data) And lastly, overlaying the infected and exposed populations on the same figure: ggplot(SEIR_data, aes(x = S, y = I)) + geom_path() + geom_path(data = SEIR_data, aes(x = S, y = E), color = &quot;plum&quot;) + theme_classic() 3.4.3 SEIHFR You aren’t responsible for being able to reproduce the code below, but I showed this model in class and am including the code below. The SEIHFR model was developed to model Ebola outbreaks. In addition to the categories of individuals included in the SEIR model, it also considers: Hospitalized individuals Deceased individuals who have not yet been buried at a Funeral. Also note that this model accounts for different transmission rates for different categories of individuals. This is to say, terms such as B are separated into Bs, Be, Bi, etc. reflectedin that fact that different sectors of society behave differently based on whether they are sick or not. SEIHFR &lt;- function(S, E, I, H, Funeral, R, # F spelled out due to protected terms Bs, Be, Bi, Bh, Bf, # All non-removed classes have beta parameters gammaH, gammaF, gammaR, # Progression rate from infection to hospitalization, death, or recovery # 1/gamma is the time to each of those fates theta, # Θ - proportion infected that are hospitalized lambda, #Λ - proportion of the sick that will die etaF, etaR, # η - Progression from hospitalization to death or recovery chi, mu, # time to burial simTime, step){ N &lt;- 1 # total population size # Lists to store values of S, I, R sList &lt;- c(S) eList &lt;- c(E) iList &lt;- c(I) hList &lt;- c(H) fList &lt;- c(Funeral) rList &lt;- c(R) for (time in seq(simTime/step)){ # Calculate rates of change # Change in number of susceptible # Interactions of susceptible individuals with Infected, Hospitalized, and dead individuals dS &lt;- (mu * (N * (1-p) - S)-(Bi * I + Bh * H + Bf * Funeral) * S / N) * step # Change in number exposed # First term: number of susceptible individuals that get exposed # Same as dS with opposite sign # Second term: number of exposed individuals that proceed to being infected dE &lt;- ((Bi * I + Bh * H + Bf * Funeral) * S / N - sigma * E) * step # Change in number of infected # First term: number of exposed that become infected # Second term: progression from infection to hospitalization # Third term: Recovery # Fourth term: Death dI &lt;- (sigma * E - theta * gammaH * I - (1 - theta) * (1 - lambda) * gammaR * I - (1 - theta) * lambda * gammaF * I) * step # Change in the number hospitalized # First term: Progression from infection to hospitalization # Second term: Progression from hospitalization to death # Third term: dH &lt;- (theta * gammaH * I - # infection to hospitalization lambda * etaF * H - # hospitalization to death (1 - lambda) * etaR * H) * step # hospitalization to recovery # Change in number dead and unburied # First term: Progression from infection to death dFuneral &lt;- ((1 - theta) * lambda * gammaF * I + # Infection to death. I think this is a typo in the textbook lambda * etaF * H - # hospitalization to death chi * Funeral ) * step # Change in number of recovered dR &lt;- ((1 - theta) * (1 - lambda) * gammaR * I + # infected recover (1 - lambda) * etaR * H # Recovery + chi * Funeral) * step # burial # Update population sizes S &lt;- S + dS E &lt;- E + dE I &lt;- I + dI H &lt;- H + dH Funeral &lt;- Funeral + dFuneral R &lt;- R + dR # Update population size based on number dead N &lt;- sum(S, E, I, H, Funeral, R) # Store to list sList &lt;- c(sList, S) eList &lt;- c(eList, E) iList &lt;- c(iList, I) hList &lt;- c(hList, H) fList &lt;- c(fList, Funeral) rList &lt;- c(rList, R) } # Store results in df df &lt;- data.frame( time = seq(length(sList)) * step, S = sList, E = eList, I = iList, H = hList, Funeral = fList, R = rList ) return(df) } Now running the simulation: # Initialize simulation parameters S &lt;- 0.99 # Susceptible E &lt;- 0.0 # Exposed I &lt;- 0.01 # Infected H &lt;- 0 # Hospitalized Funeral &lt;- 0 R &lt;- 0.0 # Recovered # Interaction length parameters Bi &lt;- 0.588 Bh &lt;- 0.794 Bf &lt;- 7.653 # Progression rate from infection gammaH &lt;- 1/5 gammaF &lt;- 1/9.6 gammaR &lt;- 1/10 # Progression from hospitalization to death or recovery etaF &lt;- 1/4.6 etaR &lt;- 1/5 theta &lt;- 0.80 # Hospitalization rate lambda &lt;- 0.81 # Death rate # Time to burial chi &lt;- 0.5 mu &lt;- 1/(50 * 52) sigma &lt;- 1/7 # Length that exposed stay exposed prior to becoming infected simTime &lt;- 52 * 3 step &lt;- 0.1 SEIHFR_data &lt;- SEIHFR(S, E, I, H, Funeral, R, Bs, Be, Bi, Bh, Bf, gammaH, gammaF, gammaR, theta,lambda, etaF, etaR, chi, mu, simTime, step) # Convert to tall format SEIHFR_data_tall &lt;- melt(SEIHFR_data, id.vars = &quot;time&quot;) colnames(SEIHFR_data_tall) &lt;- c(&quot;Time&quot;, &quot;Population&quot;, &quot;Size&quot;) ggplot(SEIHFR_data_tall[SEIHFR_data_tall$Population != &quot;R&quot;, ], aes(x = Time * step / 52, y = Size, color = Population)) + geom_line() + labs(y = &quot;Population Size&quot;) + theme_bw() + xlab(&quot;Time&quot;) "],["class-9-the-wright-fisher-model-i---neutral-evolution.html", "3.5 Class 9: The Wright-Fisher Model I - Neutral Evolution", " 3.5 Class 9: The Wright-Fisher Model I - Neutral Evolution library(ggplot2) library(reshape2) The Wright-Fisher model provides us with a simulation-based appraoch to examine the fluctuations in allele frequency across generations. This model makes a large number of assumptions about the nature of populations, including: Constant population size Everyone reproduces once per generation, at the same time No selection No mutation Random mating And while these are all simplifications compared to any real world biological system, the model allows us to make powerful predictions about genetic variation. Since this will be our first time working with random simulation, let’s first model a simpler scenario - the Random Walk. 3.5.1 Random Walks The Random Walk simulates the motion of a particle moving randomly - think of a diffusing molecule or a small bacterium. At every time step, the particle can move a distance in any direction. The direction and magnitude of motion are independent of past behavior, hence making it random (this is more formally called a Markov Process). When simulating the random walk, we can generate random x and y displacements using the runif() function. The conventional arguments for runif() are runif(n, min, max), with n being the number of random values to return and min and max being the upper and lower bounds. For example, 5 random numbers between 10 and 12: runif(n = 5, min = 10, max = 12) ## [1] 11.53847 10.85027 11.20427 11.12326 10.38034 Now, the random walk function, taking as an argument the number of time steps to walk: randomWalk &lt;- function(timeSteps){ # Initialize starting coordinates x &lt;- 0 y &lt;- 0 # Vectors to store positions x_positions &lt;- c(x) y_positions &lt;- c(y) # Loop through require number of time steps for (i in seq(timeSteps)){ # Randomly update my x and y positions x &lt;- x + runif(n = 1, min = -1, max = 1) # Can move between one unit left and one unit right y &lt;- y + runif(n = 1, min = -1, max = 1) # update lists x_positions &lt;- c(x_positions, x) y_positions &lt;- c(y_positions, y) } # Combine into data frame df &lt;- data.frame( x = x_positions, y = y_positions ) # Return the data frame to user return(df) } We can run this function once and plot the path taken: path &lt;- randomWalk(100) ggplot(path, aes(x = x, y = y)) + geom_path() + xlab(&quot;X&quot;) + ylab(&quot;Y&quot;) + theme_bw() Because there is randomness in this model, no one iteration of the random walk is sufficient to describe the overall behavior of the system. However, we can easily run our model multiple times: # Run once path &lt;- randomWalk(100) # Add a column keeping track of the trial number path[&quot;trial&quot;] &lt;- 1 # Run 999 more times for (i in seq(2, 999)){ # Note that we start with trial 2 # temporary data frame to store each iteration of the results toAdd &lt;- randomWalk(100) toAdd[&quot;trial&quot;] &lt;- i # add to path data frame path &lt;- rbind(path, toAdd) } # Plot the paths taken in each trial ggplot(path, aes(x = x, y = y, color = factor(trial))) + # trial number converted to factor to make this into discrete categories geom_path(alpha = 0.08) + # Reducing the opacity theme_bw() + xlab(&quot;X&quot;) + ylab(&quot;Y&quot;) + guides(color = &quot;none&quot;) # We remove the color legend, since it takes up the whole plotting space Each individual run is quite faint here, but you can see that in total they all cluster around the center. If we care about the ultimate expected position of the particle given an arbitrary run time, we can summarize this with a histogram: # Vectors to store final positions finalX &lt;- c() finalY &lt;- c() # Run simulation 1000 times for (i in seq(1000)){ # Run the simulation toAdd &lt;- randomWalk(100) # Get the final coordinates and add to vectors finalX &lt;- c(finalX, toAdd$x[nrow(toAdd)]) # Final x finalY &lt;- c(finalY, toAdd$y[nrow(toAdd)]) # Final y } # Convert to df df &lt;- data.frame( x = finalX, y = finalY ) # Plot as a histogram ggplot(df) + geom_histogram(aes(x = finalX), fill = &quot;plum&quot;, alpha = 0.5) + geom_histogram(aes(x = finalY), fill = &quot;turquoise&quot;, alpha = 0.5) + xlab(&quot;Position at at Time Step 100&quot;) + theme_bw() ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. Confirming our observations from the above figure, the random walk centers around the starting position. Now with these techinques under our belt, we’re ready to simulate the Wright-Fisher model. 3.5.2 Wright-Fisher Simulation Our simulation of the Wright-Fisher model is conceptually similar to the random walk. We start at some allele frequency, and every generation there is a random displacement of the allele frequency, representing the actions of genetic drift. In the random walk, displacement was drawn from the uniform distribution and the magnitude was equally likely to be any value between the min and the max. Here, since we are modelling many independent reproduction events, each of which has a probability of passing our allele to the next generation, we will instead use the binomial formula to draw the number of copies of our allele. Drawing from the binomial formula can be done using the rbinom() function. Normal use of the rbinom() function takes three parameters: rbinom(n, size, p), with n being the number of values to draw, size being the number of trials, and p being the likelihood of success for each individual trial. For example, 3 binomial values, with 10 trials each and a success rate of 80%: rbinom(n = 3, size = 10, p = 0.8) ## [1] 6 7 6 For us, the number of trials is the number of chromosomes in the population and the success rate per trial is the frequency of our allele in the population. WF &lt;- function(AF, popSize){ # Calculate the number of chromosomes in the population nChrom &lt;- 2 * popSize # Create a list to store allele frequencies across time AFs &lt;- c(AF) while (AF &lt; 1 &amp; AF &gt; 0){ # Get number of copies of my allele in next generation nAlleleNextGen &lt;- rbinom(n = 1, size = nChrom, p = AF) # Convert to allele frequency AF &lt;- nAlleleNextGen / nChrom # Add to list AFs &lt;- c(AFs, AF) } # Combined into data frame df &lt;- data.frame( time = seq(0, length(AFs) - 1), AF = AFs ) return(df) } Running this once: AF &lt;- WF(0.5, 1000) ggplot(AF, aes(x = time, y = AF)) + geom_line() + theme_classic() + ylim(0, 1) Multiple iterations of the model: # Run the model once AF &lt;- WF(1/200, 100) # Add a column to keep track of trial number AF[&quot;trial&quot;] = 1 # Run 499 more times for (i in seq(2, 500)){ # Temporary df to store current trial toAdd &lt;- WF(1/200, 100) toAdd[&quot;trial&quot;] &lt;- i # Add trial number # Add to overall df AF &lt;- rbind(AF, toAdd) } # Plot ggplot(AF, aes(x = time, y = AF, group = factor(trial))) + geom_line() + theme_classic() + ylim(0, 1) + guides(color = &quot;none&quot;) "],["r-guidebook.html", "4 R Guidebook", " 4 R Guidebook This section of the website will contain a concise texbook form introduction to the R programming language, tailored to topics covered in class. "],["data-types.html", "4.1 Data Types", " 4.1 Data Types R allows us to work with many different types of data. The crucial ones for us are: Numeric data are all numbers. For example: • 78 • 3.2 • -9.8 Characters are any text enclosed by single or double quotation marks. For example: • My Grandpa's deck has no pathetic cards • \"85.3\" Note that 85.3 - no quotes - is numeric data; \"85.3\" is character data. Logical data has three possible values: TRUE, FALSE, and NA for missing data. These are case sensitive and lack quotes (\"TRUE\" would be character data). TRUE and FALSE can also be shortened to T and F. Factors are characters with associated levels, i.e. an order. For example, imagine that you have the set of characters \"Bach\", \"Purcell\", \"Handel\" and you always want them sorted in that specific order, rather than the default alphabetical order. We can use factors to manually create such an order for our data. If this is a bit abstract right now, it’ll make more sense in practice once we work with real data! "],["variables.html", "4.2 Variables", " 4.2 Variables Variables allow us to store data in memory. When we store data in memory, we can also give it a name. We create a variable using the assignment operator &lt;- or =: variable_name &lt;- value For our purposes, these are interchangeable. For example: • composer &lt;- \"buxtehude\" • year = 1637 The variable name can be almost anything. Here are some general rules to consider when naming a variable: • Variable names must start with a letter and consist of letters, numbers, ., and _ • Some words are considered “reserved” - i.e. they are already used by R to mean something and therefore cannot be a variable name. These include TRUE, if, NULL, etc. For a full list, check here. 4.2.1 Overwriting Variables In the following code example, we assign two different values to the same variable name: myData &lt;- 3 myData &lt;- &quot;marigold&quot; What is the value of myData? It will be \"marigold\". In the first line of code, we set myData equal to 3, but then in the next line, we overwrite that value and set myData equal to \"margiold\". The previous value of myData is erased and it is set to the new value. Note that in doing so, we change not just the value of myData, but also the data type - it goes from numeric to character data. We can also do this to update the value of a variable: a_number &lt;- 5 a_number &lt;- a_number + 10 print(a_number) ## [1] 15 Here, we set the variable a_number equal to 5. In the next line, we add 10 to its value, storing the result under the same name. a_number is now equal to 15. "],["math.html", "4.3 Math", " 4.3 Math A lot of mathematical operations in R are straightforward. Here are some of the basic operations we can perform: • + and -: addition and subtraction • * and /: multiplication and division • **: exponents We can perform mathematical operations on values directly: print(2 + 3) ## [1] 5 Or we can operate on variables: x &lt;- 5 print(x**3) ## [1] 125 We can also save the output of an expression as a variable: my_product &lt;- 2 * 10 print(my_product) ## [1] 20 4.3.1 Order of Operations R follows the usual mathematical order of operations. And like in math, we can use parentheses () to enforce a specific order. print(2 * (2 + 2)) ## [1] 8 "],["comparisons.html", "4.4 Comparisons", " 4.4 Comparisons In R, comparisons will always return Logical data, i.e. either TRUE or False. We can use the following syntax to compare values: • &lt; and &gt;: greater than, less than • &lt;= and &gt;=: greater than or equal to, less than or equal to For example: print(5.3 &lt; 17) ## [1] TRUE print(4 &gt;= (8/2)) ## [1] TRUE • == checks if two values are equal. != checks if two values are different. print(2 == (10 - 8)) ## [1] TRUE Note that a single equals sign = can be used to assign values. However, a double equals sign == is used to compare values. 4.4.1 AND and OR We can evaluate multiple conditions using the logical AND and OR operators. 4.4.1.1 AND AND statements are represented using the operator &amp;. Two AND statements evaluate as TRUE only if both are TRUE. For example: (5 &gt; 2) &amp; (7 + 2 == 9) ## [1] TRUE If either statement is FALSE, the entire expression is FALSE: (5 &gt; 2) &amp; (12 == 2) ## [1] FALSE 4.4.1.2 OR OR statements are represented using the operator |. Two OR statements evaluate as TRUE if either statement is TRUE. For example: (5 &gt; 2) | (7 + 2 == 9) ## [1] TRUE If either statement is TRUE, the entire expression is TRUE: (5 &gt; 2) | (12 == 2) ## [1] TRUE "],["vectors.html", "4.5 Vectors", " 4.5 Vectors Usually, we don’t want to work with just a single data point - we will typically have multiple values that we want to store together. The most convenient way of doing this in R is using vectors. A vector stores multiple data points, preserving their order. We create a vector using the c() (short for “concatenate”) function. For example: plants &lt;- c(&quot;Feverfew&quot;, &quot;Ivy&quot;, &quot;Willow&quot;) print(plants) ## [1] &quot;Feverfew&quot; &quot;Ivy&quot; &quot;Willow&quot; The data within a vector may be of any type, but all elements of a vector must be of the same data type. What happens if we try to create a vector with multiple data types? beetles &lt;- c(&quot;Weevil&quot;, &quot;Firefly&quot;, 5) print(beetles) ## [1] &quot;Weevil&quot; &quot;Firefly&quot; &quot;5&quot; Here, we mix character and numeric data. This isn’t allowed, so the numeric 5 is converted to the string \"5\". 4.5.1 Indexing We will often want to take a larger vector and extract specific data points from it. To do this, we index our vector using the general syntax: vectorName[itemPosition] The position of the first item in the list is 1 (in other words, R is 1-indexed). Let’s try indexing using our plants vector, made above. print(plants) ## [1] &quot;Feverfew&quot; &quot;Ivy&quot; &quot;Willow&quot; To extract \"Ivy\", we would do: plants[2] ## [1] &quot;Ivy&quot; We can also use a colon to extract multiple subsequent elements: plants[1:2] ## [1] &quot;Feverfew&quot; &quot;Ivy&quot; We can also provide a vector to index multiple values: plants[c(1,3)] ## [1] &quot;Feverfew&quot; &quot;Willow&quot; We often want to extract elements near the end of a vector. plants is short and we can count to the end of it easily, but most of the data we will work with is a lot longer. One easy way to index items near the end of a vector is to use the length() function. We can index the final entry in plants as so: plants[length(plants)] ## [1] &quot;Willow&quot; length(plants) is 3, so writing plants[length(plants)] is equivalent to writing plants[3] Likewise, we can index the second element by doing some math: plants[length(plants) - 1] ## [1] &quot;Ivy&quot; 4.5.2 Logical Indexing We often want to subset our data not by the position of elements, but based on whether or not they meet a certain criterion. Below, I have generated a short list of numbers: myNumbers &lt;- c(1, 54, 12.2, 70, 18, 24, 94) Let’s say we want to extract just the values that are greater than 15 from this list. We can use any of our comparative operators with a vector to compare all values within the vector: myNumbers &gt; 15 ## [1] FALSE TRUE FALSE TRUE TRUE TRUE TRUE This generates a logical vector. We can provide this vector as an index to myNumbers to pull out the elements that are TRUE. myNumbers[myNumbers &gt; 15] ## [1] 54 70 18 24 94 We can use the logical AND (&amp;) and OR (|) operators to combine conditions. For example, extracting values greater than 15 and less than 30: myNumbers[(myNumbers &gt; 15) &amp; (myNumbers &lt; 30)] ## [1] 18 24 4.5.3 Modifying Vectors Once we point to elements within a vector, we can modify them using the assignment operator. For example, making the second item in myNumbers equal to 200: myNumbers[2] &lt;- 200 print(myNumbers) ## [1] 1.0 200.0 12.2 70.0 18.0 24.0 94.0 We can also modify multiple elements at once. For example, making every value less than 50 equal to 0: myNumbers[myNumbers &lt; 50] &lt;- 0 print(myNumbers) ## [1] 0 200 0 70 0 0 94 4.5.4 Adding to Vectors We can add to vectors using the concatenate function: plants &lt;- c(plants, &quot;Philodendron&quot;) print(plants) ## [1] &quot;Feverfew&quot; &quot;Ivy&quot; &quot;Willow&quot; &quot;Philodendron&quot; "],["data-frames.html", "4.6 Data Frames", " 4.6 Data Frames The Data Frame is a tabular data structure which can contain data of multiple types. It is conceptually similar to an Excel spreadsheet and is by far the most important data structure in R programming. In a dataframe, each column is a vector. This is to say, all elements within a column will be of the same data type. However, different columns can be of different data types. Here’s a data frame with a handful of writers, their birth years, and whether or not they were poets. writers &lt;- data.frame( Name = c(&quot;Plath&quot;, &quot;Tolstoy&quot;, &quot;Milton&quot;, &quot;Woolf&quot;, &quot;Farid ud-Din Attar&quot;), BirthYear = c(1932, 1828, 1608, 1882, 1145), Poet = c(TRUE, FALSE, TRUE, FALSE, TRUE) ) print(writers) ## Name BirthYear Poet ## 1 Plath 1932 TRUE ## 2 Tolstoy 1828 FALSE ## 3 Milton 1608 TRUE ## 4 Woolf 1882 FALSE ## 5 Farid ud-Din Attar 1145 TRUE Note that when we set the names of our columns, we must use the equals sign - we cannot use the assignment &lt;- as that is only used for variable assignment (i.e. we cannot do Poet &lt;- c(TRUE, FALSE, TRUE, FALSE, TRUE)) 4.6.1 Subsetting Data Frames When we indexed vectors, we used the bracket notation vector[index] to extract information. We can do the same for data frames, but now we must provide two values - one for the row index and one for the column index, so the syntax is dataFrame[row, column]. For example, to pull out the value 1608 from writers, we would do: writers[3,2] ## [1] 1608 As with vectors, we can extract multiple elements at once: writers[c(2,3), c(1, 2)] ## Name BirthYear ## 2 Tolstoy 1828 ## 3 Milton 1608 What if we want to subset the rows, but keep all the columns of our data frame? We can leave a field blank to not subset it at all. For example, pulling out all columns for rows 2 and 3: writers[c(2,3), ] ## Name BirthYear Poet ## 2 Tolstoy 1828 FALSE ## 3 Milton 1608 TRUE However, there is an easier way of extracting infromation from a data frame - we can take advantage of row names. We can pull out individual vectors from a data frame using the syntax dataFrame$columnName. For example, we can extract the Name vector from writers using: writers$Name ## [1] &quot;Plath&quot; &quot;Tolstoy&quot; &quot;Milton&quot; ## [4] &quot;Woolf&quot; &quot;Farid ud-Din Attar&quot; And then we can index the Name as we would any other vector: writers$Name[2] ## [1] &quot;Tolstoy&quot; 4.6.2 Logical Indexing As with vectors, we can use logic and comparison operators to subset data frames. For example, we can subset our data frame just to writers who are poets: poetsVector &lt;- writers$Poet == TRUE # Get the positions of writers who are poets writers[poetsVector, ] # Subset our data ## Name BirthYear Poet ## 1 Plath 1932 TRUE ## 3 Milton 1608 TRUE ## 5 Farid ud-Din Attar 1145 TRUE Notice how here, we save the logical vector as its own variable (poetsVector). We’re doing the equivalent of writers[writers$Poet == TRUE], but you may find dividing this process into multiple lines easier, especially as logic gets more complex. "],["plotting-1.html", "4.7 Plotting", " 4.7 Plotting The base R programming language comes with some pretty robust tools for plotting. However, most R users instead use the external library ggplot2, which simplifies plotting and allows for more elaborate data visualization. Your Posit cloud accounts have ggplot2 pre-installed. However, at the start of each script where you plot, you must let R know that you will use an external package with the line: library(ggplot2) For a simple dataset to plot, I’ve saved the temperature in Fahrenheit in Baltimore, MD and Wommels, Netherlands for the next seven hours: temperatures = data.frame( hours = seq(1,7), temperature = c(74, 73, 72, 71, 75, 79, 87, 59, 60, 62, 65, 69, 72, 67), city = c(rep(&quot;Baltimore&quot;, 7), rep(&quot;Wommels&quot;, 7)) ) head(temperatures) ## hours temperature city ## 1 1 74 Baltimore ## 2 2 73 Baltimore ## 3 3 72 Baltimore ## 4 4 71 Baltimore ## 5 5 75 Baltimore ## 6 6 79 Baltimore We can initialize a blank canvas with a call to the ggplot() function. The first argument that this function takes is the dataset you wish to plot, which in our case is temperatures. ggplot(temperatures) Next, we have to define the axes, groups of data, and other aesthetics. This is done with the aes argument. For our data, it makes sense to have time be the x axis and temperature to be the y axis: ggplot(temperatures, aes(x = hours, y = temperature)) We now have a blank plot with axes. Notice that the scales of our axes are automatically set by the scales of our data (hours ranges from 0 to 7; temperature ranges approximately from 60 to 90). Now to add some data to our plot. Because ggplot already knows our input data and how the axes are laid out, all we need to do is to say that type of visualization we want (e.g. points, lines, etc.). Let’s start by adding points to our plot: ggplot(temperatures, aes(x = hours, y = temperature)) + geom_point() This plots our data correctly, but notice that we can’t distinguish between the two cities visually. We can group our data points by coloring them differently. To do this, we can add another argument (color) to our aes statement: ggplot(temperatures, aes(x = hours, y = temperature, color = city)) + geom_point() This is a pretty clear, interpretable plot! We can pretty easily make a few changes to make it look nicer, though. First, let’s also add a line by adding a geom_line() statement: ggplot(temperatures, aes(x = hours, y = temperature, color = city)) + geom_point() + geom_line() ggplot will automatically generate axis labels based on the column names of the input data. However, we can also make more descriptive x and y axis labels along with an overall figure title using xlab(), ylab(), and ggtitle(), respectively: ggplot(temperatures, aes(x = hours, y = temperature, color = city)) + geom_point() + geom_line() + xlab(&quot;Time (Hours)&quot;) + ylab(&quot;Temperature (F)&quot;) + ggtitle(&quot;Projected Temperatures for the Next Six Hours&quot;) Lastly, it is worth mentioning that we can add theme() statements to modify almost any aspect of our figure’s aesthetics. Along with manually defined theme() statements, ggplot comes with a handful of predefined themes: ggplot(temperatures, aes(x = hours, y = temperature, color = city)) + geom_point() + geom_line() + xlab(&quot;Time (Hours)&quot;) + ylab(&quot;Temperature (F)&quot;) + ggtitle(&quot;Projected Temperatures for the Next Six Hours&quot;) + theme_classic() ggplot(temperatures, aes(x = hours, y = temperature, color = city)) + geom_point() + geom_line() + xlab(&quot;Time (Hours)&quot;) + ylab(&quot;Temperature (F)&quot;) + ggtitle(&quot;Projected Temperatures for the Next Six Hours&quot;) + theme_bw() "],["lecture-slides.html", "5 Lecture Slides", " 5 Lecture Slides Slides from all class session will be hosted on this page. Lecture 1 (8/27) Lecture 3 (9/3) Lecture 4 (9/5) Lecture 5 (9/10) Lecture 6 (9/12) Lecture 7 (9/17) Lecture 9 (9/24) Lecture 10 (9/26) Lecture 13 (10/8) Lecture 14 (10/10) Lecture 15 (10/15) "],["authors.html", "Authors", " Authors     Credits Names Pedagogy Instructor Andrew Bortvin Content Author Andrew Bortvin Website Template Jeff Leek &amp; The Johns Hopkins Data Science Lab Design Inspiration Stephanie Yan &amp; Ali Madooei &amp; JHU Data Structures Funding JHU Dean’s Teaching Fellowship   ## ─ Session info ─────────────────────────────────────────────────────────────── ## setting value ## version R version 4.3.2 (2023-10-31) ## os Ubuntu 22.04.4 LTS ## system x86_64, linux-gnu ## ui X11 ## language (EN) ## collate en_US.UTF-8 ## ctype en_US.UTF-8 ## tz Etc/UTC ## date 2024-10-18 ## pandoc 3.1.1 @ /usr/local/bin/ (via rmarkdown) ## ## ─ Packages ─────────────────────────────────────────────────────────────────── ## package * version date (UTC) lib source ## askpass 1.2.0 2023-09-03 [1] RSPM (R 4.3.0) ## bookdown 0.40 2024-07-02 [1] CRAN (R 4.3.2) ## bslib 0.6.1 2023-11-28 [1] RSPM (R 4.3.0) ## cachem 1.0.8 2023-05-01 [1] RSPM (R 4.3.0) ## chromote 0.3.1 2024-08-30 [1] CRAN (R 4.3.2) ## cli 3.6.2 2023-12-11 [1] RSPM (R 4.3.0) ## colorspace 2.1-0 2023-01-23 [1] RSPM (R 4.3.0) ## devtools 2.4.5 2022-10-11 [1] RSPM (R 4.3.0) ## digest 0.6.34 2024-01-11 [1] RSPM (R 4.3.0) ## dplyr 1.1.4 2023-11-17 [1] RSPM (R 4.3.0) ## ellipsis 0.3.2 2021-04-29 [1] RSPM (R 4.3.0) ## evaluate 0.23 2023-11-01 [1] RSPM (R 4.3.0) ## fansi 1.0.6 2023-12-08 [1] RSPM (R 4.3.0) ## farver 2.1.1 2022-07-06 [1] RSPM (R 4.3.0) ## fastmap 1.1.1 2023-02-24 [1] RSPM (R 4.3.0) ## fs 1.6.3 2023-07-20 [1] RSPM (R 4.3.0) ## generics 0.1.3 2022-07-05 [1] RSPM (R 4.3.0) ## ggplot2 * 3.5.0 2024-02-23 [1] RSPM (R 4.3.0) ## glue 1.7.0 2024-01-09 [1] RSPM (R 4.3.0) ## gtable 0.3.4 2023-08-21 [1] RSPM (R 4.3.0) ## highr 0.11 2024-05-26 [1] CRAN (R 4.3.2) ## hms 1.1.3 2023-03-21 [1] RSPM (R 4.3.0) ## htmltools 0.5.7 2023-11-03 [1] RSPM (R 4.3.0) ## htmlwidgets 1.6.4 2023-12-06 [1] RSPM (R 4.3.0) ## httpuv 1.6.14 2024-01-26 [1] RSPM (R 4.3.0) ## httr 1.4.7 2023-08-15 [1] RSPM (R 4.3.0) ## janitor 2.2.0 2023-02-02 [1] RSPM (R 4.3.0) ## jquerylib 0.1.4 2021-04-26 [1] RSPM (R 4.3.0) ## jsonlite 1.8.8 2023-12-04 [1] RSPM (R 4.3.0) ## knitr 1.48 2024-07-07 [1] CRAN (R 4.3.2) ## labeling 0.4.3 2023-08-29 [1] RSPM (R 4.3.0) ## later 1.3.2 2023-12-06 [1] RSPM (R 4.3.0) ## lifecycle 1.0.4 2023-11-07 [1] RSPM (R 4.3.0) ## lubridate 1.9.3 2023-09-27 [1] RSPM (R 4.3.0) ## magrittr 2.0.3 2022-03-30 [1] RSPM (R 4.3.0) ## memoise 2.0.1 2021-11-26 [1] RSPM (R 4.3.0) ## mime 0.12 2021-09-28 [1] RSPM (R 4.3.0) ## miniUI 0.1.1.1 2018-05-18 [1] RSPM (R 4.3.0) ## munsell 0.5.0 2018-06-12 [1] RSPM (R 4.3.0) ## openssl 2.1.1 2023-09-25 [1] RSPM (R 4.3.0) ## ottrpal 1.3.0 2024-10-10 [1] Github (jhudsl/ottrpal@2e19782) ## pillar 1.9.0 2023-03-22 [1] RSPM (R 4.3.0) ## pkgbuild 1.4.3 2023-12-10 [1] RSPM (R 4.3.0) ## pkgconfig 2.0.3 2019-09-22 [1] RSPM (R 4.3.0) ## pkgload 1.3.4 2024-01-16 [1] RSPM (R 4.3.0) ## processx 3.8.3 2023-12-10 [1] RSPM (R 4.3.0) ## profvis 0.3.8 2023-05-02 [1] RSPM (R 4.3.0) ## promises 1.2.1 2023-08-10 [1] RSPM (R 4.3.0) ## ps 1.7.6 2024-01-18 [1] RSPM (R 4.3.0) ## purrr 1.0.2 2023-08-10 [1] RSPM (R 4.3.0) ## R6 2.5.1 2021-08-19 [1] RSPM (R 4.3.0) ## Rcpp 1.0.12 2024-01-09 [1] RSPM (R 4.3.0) ## readr 2.1.5 2024-01-10 [1] RSPM (R 4.3.0) ## remotes 2.4.2.1 2023-07-18 [1] RSPM (R 4.3.0) ## rlang 1.1.4 2024-06-04 [1] CRAN (R 4.3.2) ## rmarkdown 2.25 2023-09-18 [1] RSPM (R 4.3.0) ## rprojroot 2.0.4 2023-11-05 [1] CRAN (R 4.3.2) ## rstudioapi 0.15.0 2023-07-07 [1] RSPM (R 4.3.0) ## sass 0.4.8 2023-12-06 [1] RSPM (R 4.3.0) ## scales 1.3.0 2023-11-28 [1] RSPM (R 4.3.0) ## sessioninfo 1.2.2 2021-12-06 [1] RSPM (R 4.3.0) ## shiny 1.8.0 2023-11-17 [1] RSPM (R 4.3.0) ## snakecase 0.11.1 2023-08-27 [1] RSPM (R 4.3.0) ## stringi 1.8.3 2023-12-11 [1] RSPM (R 4.3.0) ## stringr 1.5.1 2023-11-14 [1] RSPM (R 4.3.0) ## tibble 3.2.1 2023-03-20 [1] CRAN (R 4.3.2) ## tidyselect 1.2.0 2022-10-10 [1] RSPM (R 4.3.0) ## timechange 0.3.0 2024-01-18 [1] RSPM (R 4.3.0) ## tzdb 0.4.0 2023-05-12 [1] RSPM (R 4.3.0) ## urlchecker 1.0.1 2021-11-30 [1] RSPM (R 4.3.0) ## usethis 2.2.3 2024-02-19 [1] RSPM (R 4.3.0) ## utf8 1.2.4 2023-10-22 [1] RSPM (R 4.3.0) ## vctrs 0.6.5 2023-12-01 [1] RSPM (R 4.3.0) ## webshot2 0.1.1 2023-08-11 [1] CRAN (R 4.3.2) ## websocket 1.4.2 2024-07-22 [1] CRAN (R 4.3.2) ## withr 3.0.0 2024-01-16 [1] RSPM (R 4.3.0) ## xfun 0.48 2024-10-03 [1] CRAN (R 4.3.2) ## xml2 1.3.6 2023-12-04 [1] RSPM (R 4.3.0) ## xtable 1.8-4 2019-04-21 [1] RSPM (R 4.3.0) ## yaml 2.3.8 2023-12-11 [1] RSPM (R 4.3.0) ## ## [1] /usr/local/lib/R/site-library ## [2] /usr/local/lib/R/library ## ## ────────────────────────────────────────────────────────────────────────────── "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
